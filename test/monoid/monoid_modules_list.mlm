(**********************************************************************)
(*                                                                    *)
(*                           Moca                                     *)
(*                                                                    *)
(*          Pierre Weis, INRIA Rocquencourt                           *)
(*          Frédéric Blanqui, projet Protheo, INRIA Lorraine          *)
(*                                                                    *)
(*  Copyright 2005-2008,                                              *)
(*  Institut National de Recherche en Informatique et en Automatique. *)
(*  All rights reserved.                                              *)
(*                                                                    *)
(*  This file is distributed under the terms of the Q Public License. *)
(*                                                                    *)
(**********************************************************************)

(* $Id: monoid_modules_list.mlm,v 1.3 2010-11-22 16:29:10 bonichon Exp $ *)

(* Free left, right and bi modules over a free monoid 
 * Should be done functorially!
 *)

(* Monoid <'a> freely generated by type 'a *)
type 'a mon_t = private
   | Unit
   | Gen of 'a
   | Mult of 'a mon_t list
     begin
       associative
       neutral (Unit)
     end
;;

(* <'a>-left module freely generated by type 'b *)
type ('a, 'b) lmod_t = private
   | LGen of 'b
   | LAct of 'a mon_t * ('a, 'b) lmod_t
     begin
       neutral left (Unit)
       rule LAct(m, LAct(n, x)) -> LAct(Mult [m; n], x) 
     end 
;;	

(* <'a>-right module freely generated by type 'b *)
type ('a, 'b) rmod_t = private
   | RGen of 'b
   | RAct of ('a, 'b) rmod_t * 'a mon_t
     begin
       neutral right (Unit)
       rule RAct(RAct(x, m), n) -> RAct(x, Mult [m; n]) 
     end 
;;	

(* <'a>-<'b>-bimodule freely generated by type 'c *)
type ('a, 'b, 'c) bmod_t = private
   | BGen of 'c
   | BLAct of 'a mon_t * ('a, 'b, 'c) bmod_t
     begin
       neutral left (Unit)
       rule BLAct(m, BLAct(n, x)) -> BLAct(Mult [m; n], x) 
     end 
   | BRAct of ('a, 'b, 'c) bmod_t * 'b mon_t
     begin
       neutral right (Unit)
       rule BRAct(BRAct(x, m), n) -> BRAct(x, Mult [m; n]) 
       rule BRAct(BLAct(m, x), n) -> BLAct(m, BRAct (x, n))
     end 
;;

